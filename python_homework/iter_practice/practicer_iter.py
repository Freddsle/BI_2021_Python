
# 1. Сделайте генератор, который принимает на вход путь к фаста файлу и 
# выдаёт по очереди пары id последовательности (то, что после ">") и последовательности. (5 баллов)
# Пример использования на рисунке Example1. 
# Обратите внимание, что функция должна возвращать НЕ список, а генератор! 
# Биопитон и другие библиотеки не используем.


def generator_idfasta(fasta_path='../data/sequences.fasta'):


    return 



# 2. Напишите класс, производящий чтение последовательностей с небольшими изменениями. (15 баллов)
# Класс должен иметь конструктор хотя бы с одним аргументом - путь к фаста файлу
# Объект данного класса должен поддерживать итерацию по нему. Не по атрибутам, а именно по самому объекту.
# В процессе итерации класс бесконечно перебирает последовательности в файле. Если файл закончился, то итерация продолжается с его начала.
# При возвращении каждой очередной последовательности класс немного изменяет её с заданной вероятностью (способ задачи вероятности придумайте сами). 
# Можно менять часть аминокислот, делать делеции, вставки и т.д.. Функционал для изменения последовательностей выделите в отдельный(е) метод(ы).
# Наследоваться запрещается





# 1. Напишите генератор iter_append(iterable, item), который "добавляет" элемент item в "конец" iterable. (5 доп баллов)
# То есть при итерации по iter_append(iterable, item) мы сначала будем получать данные из iterable, а в самом конце одно значение item. 
# Пример использования на рисунке Example3
# Напишите этот генератор без явных циклов (без конструкций while, for и list comprehensions)
# Не используйте никакие другие функции в теле iter_append






# 2. Сделайте функцию, которая "распаковывает" вложенные списки (5 доп баллов)
# Уровень вложенности списков может быть любым. Пример использования на рисунке Example2.
# Подсказка: используйте генераторы и синтаксис из предыдущего задания




if __init __:
    pass